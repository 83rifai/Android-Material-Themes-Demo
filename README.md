#Android Material Themes Made Easy


###Styles And Themes
Android was built with the concept that almost every user interface element should be customizable, and apps should be able to adjust their look and feel to express their brand, while keeping common behaviors that users understand. To support this, Android has [styles](http://developer.android.com/guide/topics/resources/style-resource.html), which are a collection of [attributes](http://developer.android.com/training/custom-views/create-view.html#customattr) that can be applied to a [`View`](http://developer.android.com/reference/android/view/View.html), which adjusts colors, dimensions, spacing, fonts, and any other attributes that the `View` supports. Now here's where it starts getting convoluted, Android also has themes, which are actually just styles, that are applied to an [`Activity`](http://developer.android.com/reference/android/app/Activity.html) or an entire [`Application`](http://developer.android.com/reference/android/app/Application.html). The difference is, when a style is used as a theme for an `Activity` or `Application`, it applies to all `Views` in that hierarchy. To sum it up, a style is applied at a local, individual component level, while themes are applied at a more global page or application level.

###Understanding Attributes
So we know styles and themes set attributes, but wait, what really is an attribute? You can think of attributes just like variables, that represent properties that can be set, changed, and are ultimately to be used by the user interface to define look and behavior. Attributes can be defined in `attrs.xml` and show up as references in the autogenerated `R` file. The attributes defined by the Android SDK can be found in the [`R.attr`](http://developer.android.com/reference/android/R.attr.html) file. Of course, apps can add their own attributes to use with their own custom `Views` and themes, but we will get to that later.

The simplest use case for an attribute is an explicit property that a `View` will apply. For example, `TextView` supports the attribute `android:textColor`, which sets a specific color for its text. So keeping the "*attributes are like variables*" comparison, in Java terms, we are basically setting the `textColor` variable to a constant.

```java
int textColor = 0x00FF00;
```

In XML, we would use a simple style that sets `android:textColor` to a color in `styles.xml`

```xml
<style name="TextStyle" parent="TextAppearance.AppCompat">
	<item name="android:textColor">#00FF00</item>
</style>
```

Just like variables, attributes can reference other attributes. This enables a more complex use for attributes as theme properties, where they do not correspond to explicit `View` properties, but are instead properties that can be used by attributes that set explicit `View` properties. For example, the default Android theme includes the attribute `android:textColorPrimary`, which is not a property of any `View`, but is used by `TextView` and its subclasses to apply to the attribute `android:textColor`. Going back to the "*attributes are like variables*" comparison, in Java terms, we are now setting the `textColorPrimary` variable to a constant, which is then being set to `textColor`.

```java
int textColorPrimary = 0x00FF00;
int textColor = textColorPrimary;
```

In XML, we would use a theme that sets `android:textColorPrimary` to a color, and a style that sets `android:textColor` to `?android:textColorPrimary` in `styles.xml`

```xml
<style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
	<item name="android:textColorPrimary">#00FF00</item>
</style>

<style name="TextStyle" parent="TextAppearance.AppCompat">
	<item name="android:textColor">?android:textColorPrimary</item>
</style>
```

Now you should see the delineation between styles and themes starting to surface. Styles are great for applying explicit `View` attributes. Likewise, while a theme can also set explicit `View` attributes, *only* a theme can set theme attributes, which can then in turn be used by styles which reference those theme attributes. Putting this all together, themes can create a palette of theme attributes, which styles use to apply to explicit `View` attributes. This way, a theme sets the overall brand, while a style use that brand and uses it in particular variations for  `Views`. This allows themes to be swapped out, changing the entire look of an entire `Activity` or `Application` with minimal code changes.


###It's A Material World
Google unveiled [Material Design](https://www.google.com/design/spec/material-design/introduction.html) back in Summer 2014 alongside [Android 5.0 (API 21)](http://developer.android.com/about/versions/lollipop.html), which was a strong divergence from the Holo theme that had been around since Fall 2011 with [Android 4.0 (API 14)](http://developer.android.com/about/versions/android-4.0-highlights.html). Material design added new animations, user interface controls, touch feedback, and a bright new color palette. Google, as expected, immediately began encouraging Android app developers to incorporate Material Design elements into their apps. Developers, as expected, immediately began asking Google how they could do this and keep compatibility with legacy devices, since a [majority of devices were (and still are) running pre Android 5.0](http://developer.android.com/about/dashboards/index.html). 

TBD

###Consolidating Your Assets 
TBD